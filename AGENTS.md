<!-- OPENSPEC:START -->
# OpenSpec Instructions

These instructions are for AI assistants working in this project.

Always open `@/openspec/AGENTS.md` when the request:
- Mentions planning or proposals (words like proposal, spec, change, plan)
- Introduces new capabilities, breaking changes, architecture shifts, or big performance/security work
- Sounds ambiguous and you need the authoritative spec before coding

Use `@/openspec/AGENTS.md` to learn:
- How to create and apply change proposals
- Spec format and conventions
- Project structure and guidelines

Keep this managed block so 'openspec update' can refresh the instructions.

<!-- OPENSPEC:END -->

## Architecture Components

### Go Backend (`go-backend/`)
- **Purpose**: A wrapper around AnyStore providing both desktop and mobile implementations
- **Technology**: Go with gRPC and Protocol Buffers for the desktop server; gomobile for mobile FFI bindings
- **Testing**: Unit tests in `desktop/api/server/health_test.go`

### Rust Plugin (`src/`)
- **Purpose**: Tauri plugin that manages Go sidecar process and provides TypeScript API
- **Key Files**:
  - `lib.rs` - Plugin registration and (internal) unified service API
  - `desktop.rs` - Sidecar process management and gRPC client
  - `mobile.rs` - FFI bindings for mobile platforms
  - `commands.rs` - Tauri command handlers (external unified API)
  - `models.rs` - Data transfer types
  - `proto/` - Generated gRPC client code

### TypeScript API (`guest-js/`)
- **Purpose**: Frontend API with Promise-based interface
- **Error Handling**: Structured error propagation from Go backend

### Example App (`examples/tauri-app/`)
- **Purpose**: Demonstration of plugin functionality and testing ground
- **UI**: Svelte frontend with ping test button

## Development Workflow

Use Taskfile commands from the project root to build and test all components:
- `task build` - Builds Go backend binaries, Rust plugin, and TypeScript API
- `task clean` - Cleans all build artifacts

Use `task --list` to see all available tasks and their descriptions.

### Adding New API Operations

When adding a new operation (e.g., `storageDelete`), follow these steps across all layers:

#### 1. Protocol Definition (Protobuf)
- **File**: `go-backend/desktop/proto/{service}.proto`
- **Actions**: Add RPC method, request/response messages

#### 2. Go Backend Implementation
- **Files**: `go-backend/desktop/api/server/{service}.go`, `go-backend/shared/storage/*.go`
- **Actions**: Implement business logic, add gRPC handler, write unit tests

#### 3. Rust Plugin Integration
- **Files**: `src/models.rs`, `src/desktop.rs`, `src/mobile.rs`, `src/commands.rs`, `src/lib.rs`
- **Actions**:
  1. Register command in `lib.rs` invoke_handler and `AnySyncService` API
  2. Add request/response structs in `models.rs`
  3. Add gRPC implementation in `desktop.rs`
  4. Add FFI implementation in `mobile.rs`
  5. Add command handler in `commands.rs`

#### 4. Tauri Permission System
- **Files**: `permissions/default.toml`, `permissions/schemas/schema.json`, `permissions/autogenerated/commands/{command}.toml`
- **Actions**: Update all 3 files with `allow-{command}` and `deny-{command}` entries

#### 5. TypeScript API
- **File**: `guest-js/index.ts`
- **Actions**: Add typed function with comprehensive JSDoc, then `bun run build`

#### 6. Example App UI
- **File**: `examples/tauri-app/src/App.svelte`
- **Actions**: Add handler, UI elements, and UX considerations

#### 7. Build
```bash
task build
```

This builds Go backend binaries, Rust plugin, and TypeScript API in one command.

#### Common Pitfalls
- **Permission files**: All 3 must be updated and plugin rebuilt
- **Sidecar binary**: Example app uses old binary until Go backend rebuilt
- **Type alignment**: Ensure proto ↔ Rust ↔ TypeScript types match

## Build System Integration

### Binary Distribution Architecture

The plugin uses an automated binary distribution system with two distinct modes:

**Consumer/CI Mode (Production)**:
- Plugin downloads pre-compiled Go binaries from GitHub Releases
- Binaries are verified using SHA256 checksums
- Consumer's `build.rs` copies binaries to `src-tauri/binaries/`
- Enabled via Cargo features (e.g., `features = ["all"]` or `["macos"]`)

**Local Development Mode**:
- Set `ANY_SYNC_GO_BINARIES_DIR` environment variable to local binaries path
- Plugin copies binaries from local directory instead of downloading
- Allows developers to test Go backend changes immediately
- No network dependency for development workflows

### Build Flow

**Plugin Build** (`build.rs`):
1. Check for `ANY_SYNC_GO_BINARIES_DIR` environment variable
2. **If set** (development mode):
   - Copy binaries from local path to `OUT_DIR/binaries/`
   - Emit warning message
3. **If not set** (consumer/CI mode):
   - Determine enabled features (e.g., `macos`, `windows`)
   - Download binaries from GitHub Releases for plugin version
   - Download and parse `checksums.txt` from release assets
   - Verify SHA256 checksums for each binary (desktop + mobile)
   - Store verified binaries in `OUT_DIR/binaries/`
   - Fail build with clear error if download or verification fails
4. **For Android**: Symlink (Unix) or copy (Windows) `any-sync-android.aar` from binaries to `android/libs/`
5. Emit `cargo:binaries_dir=<path>` for consumer propagation (both modes)

**Note**: In development mode, symlinks are used instead of copying to save disk space and improve build times. On Windows, files are copied as a fallback since symlinks require admin privileges.

**Android .aar Placement**: The plugin's build.rs automatically manages the .aar placement by creating a symlink/copy to `android/libs/any-sync-android.aar`. This allows the plugin's `android/build.gradle.kts` to reference `implementation(files("libs/any-sync-android.aar"))` relative to its own directory, which works in both development (local path) and production (published crate) scenarios.

**Consumer Build** (`build.rs` in consuming app):
1. Read `DEP_TAURI_PLUGIN_ANY_SYNC_BINARIES_DIR` environment variable from plugin
2. Create symlink to binaries directory (or copy on Windows) at `src-tauri/binaries/`
3. Configure `externalBin` in `tauri.conf.json` to bundle binaries
4. Add `.taurignore` to prevent rebuild loops from file watcher

### Cargo Configuration

**Features** (select which platforms to download):
- `all`
  - `desktop`
    - `macos`
      - `x86_64-apple-darwin`
      - `aarch64-apple-darwin`
    - `linux`
      - `x86_64-unknown-linux-gnu`
      - `aarch64-unknown-linux-gnu`
    - `windows`
      - `x86_64-pc-windows-msvc`
  - `mobile`
    - `android`

**Links** (`links = "tauri-plugin-any-sync"`):
- Enables metadata propagation via environment variables
- Allows consumer `build.rs` to receive `DEP_TAURI_PLUGIN_ANY_SYNC_BINARIES_DIR`

## Communication Flow

### Desktop (gRPC Sidecar)
```
TypeScript → Rust Commands → Desktop Service → gRPC Client → Go Sidecar → AnyStore
```
- Go backend runs as separate process (bundled binary)
- IPC via gRPC over localhost

### Mobile (gomobile binaries Embedded)
```
TypeScript → Rust Commands → Mobile Service → Kotlin/Swift Plugin → JNI/FFI → Go Library → AnyStore
```
- Go backend compiled as native library (.aar/.xcframework)
- Direct in-process function calls via gomobile

**Shared:** Same TypeScript API, same Go storage layer (>95% code reuse)
