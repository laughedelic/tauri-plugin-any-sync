#!/usr/bin/env -S bun run
/**
 * Buf plugin to generate a typed SyncSpace client with generic dispatch pattern.
 * This script uses @bufbuild/protoplugin to integrate with buf's code generation pipeline.
 *
 * It uses the types generated by the standard protobuf-es plugin and builds a client
 * that serializes/deserializes messages and dispatches commands to the Tauri backend
 * via the `plugin:any-sync|command` invoke.
 */
import {
	createEcmaScriptPlugin,
	type GeneratedFile,
	runNodeJs,
	type Schema,
} from "@bufbuild/protoplugin";

runNodeJs(
	createEcmaScriptPlugin({
		name: "gen-ts-tauri",
		version: "v1",
		generateTs,
	}),
);

function generateTs(schema: Schema) {
	for (const file of schema.files) {
		const f = schema.generateFile(`${file.name}_api.ts`);

		const fileName = file.name.split("/").pop() || file.name;

		f.print`import * as pb from "./${fileName}_pb";`;
		const Message = f.import("Message", "@bufbuild/protobuf").toTypeOnly();

		// Utility type to expand mapped types for better readability
		f.print`type Expand<T> = { [K in keyof T]: T[K]; } & {};`;

		// Export raw message types ommiting protobuf internals
		for (const message of file.messages) {
			f.print`export type ${message.name} = Expand<Omit<pb.${message.name}, keyof ${Message}<"${message.typeName}">>>;`;
			f.print();
		}

		// Generate Client
		for (const service of file.services) {
			const serviceName = service.name.replace(/Service$/, "");
			const className = `${serviceName}Client`;

			f.print(f.jsDoc(service));
			f.print`export class ${className} {`;

			generateDispatchMethod(f);

			for (const method of service.methods) {
				// Don't add empty request params
				const input = method.input.members.length
					? `request: ${method.input.name}`
					: "";
				const request = input ? "request" : "{}";

				f.print(f.jsDoc(method, "  "));
				f.print`public async ${method.localName}(${input}): Promise<${method.output.name}> {
            return await this.dispatch("${method.name}", pb.${method.input.name}Schema, pb.${method.output.name}Schema, ${request});
          }`;
				f.print();
			}
			f.print`}`;
			f.print();

			// Export singleton instance for convenience
			f.print(
				f.export("const", serviceName.toLowerCase()),
				" = new ",
				className,
				"();",
			);
		}
	}
}

function generateDispatchMethod(f: GeneratedFile) {
	const MessageShape = f
		.import("MessageShape", "@bufbuild/protobuf")
		.toTypeOnly();
	const MessageInitShape = f
		.import("MessageInitShape", "@bufbuild/protobuf")
		.toTypeOnly();
	const DescMessage = f
		.import("DescMessage", "@bufbuild/protobuf")
		.toTypeOnly();
	const { create, fromBinary, toBinary } = f.runtime;
	const invoke = f.import("invoke", "@tauri-apps/api/core");

	// Private generic call method
	f.print`
    private async dispatch<
      ReqSchema extends ${DescMessage}, 
      ReqShape extends ${MessageInitShape}<ReqSchema>, 
      ResSchema extends ${DescMessage},
      ResShape extends ${MessageShape}<ResSchema>,
    >(
      cmd: string,
      reqSchema: ReqSchema,
      resSchema: ResSchema,
      req: ReqShape
    ): Promise<ResShape> {
      try {
        // Serialize: Interface -> Uint8Array
        const instance = ${create}(reqSchema, req);
        const data = ${toBinary}(reqSchema, instance);

        // Invoke: Uint8Array -> Uint8Array (Direct!)
        const response = await ${invoke}<Uint8Array>("plugin:any-sync|command", { cmd, data });

        // Deserialize: Uint8Array -> Interface
        return ${fromBinary}(resSchema, response) as ResShape;
      } catch (error) {
        throw new Error(
          \`Failed to execute command '\${cmd}': \${error instanceof Error ? error.message : String(error)}\`,
        );
      }
    }
  `;
}
