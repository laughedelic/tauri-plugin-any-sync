// Package anysync provides Any-Sync integration components.
package anysync

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"

	anystore "github.com/anyproto/any-store"
	"github.com/anyproto/any-sync/commonspace/object/accountdata"
	"github.com/anyproto/any-sync/commonspace/spacepayloads"
	"github.com/anyproto/any-sync/commonspace/spacestorage"
	"github.com/anyproto/any-sync/util/crypto"
)

// SpaceMetadata holds application-level space metadata.
// This is stored separately from Any-Sync's internal space structure.
type SpaceMetadata struct {
	SpaceID   string            `json:"space_id"`
	Name      string            `json:"name"`
	Metadata  map[string]string `json:"metadata"`
	CreatedAt int64             `json:"created_at"`
	UpdatedAt int64             `json:"updated_at"`
}

// SpaceManager manages local spaces with full Any-Sync structure.
//
// Current Implementation (Phase 2C):
// - Creates SpaceStorage directly using spacestorage.Create()
// - Manages space metadata and storage lifecycle
// - Works for basic space CRUD operations
//
// Phase 2D Requirements:
// - Need commonspace.Space objects (not just SpaceStorage) to access TreeBuilder
// - TreeBuilder is required for creating/managing ObjectTrees (documents)
// - Will need to integrate app.App with SpaceService to get Space objects
type SpaceManager struct {
	mu         sync.RWMutex
	dataDir    string
	keys       *accountdata.AccountKeys
	spaces     map[string]*SpaceMetadata            // In-memory cache of space metadata
	storages   map[string]spacestorage.SpaceStorage // Opened space storages
	storageDir string                               // Directory for space storage databases
	// TODO Phase 2D: Add spaceObjects map[string]commonspace.Space
	// TODO Phase 2D: Add app.App and commonspace.SpaceService fields
}

// NewSpaceManager creates a new SpaceManager.
func NewSpaceManager(dataDir string, keys *accountdata.AccountKeys) (*SpaceManager, error) {
	if keys == nil {
		return nil, fmt.Errorf("account keys required")
	}

	storageDir := filepath.Join(dataDir, "spaces")
	if err := os.MkdirAll(storageDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create storage directory: %w", err)
	}

	sm := &SpaceManager{
		dataDir:    dataDir,
		keys:       keys,
		spaces:     make(map[string]*SpaceMetadata),
		storages:   make(map[string]spacestorage.SpaceStorage),
		storageDir: storageDir,
	}

	// Load existing space metadata
	if err := sm.loadMetadata(); err != nil {
		return nil, fmt.Errorf("failed to load space metadata: %w", err)
	}

	return sm, nil
}

// CreateSpace creates a new space with full Any-Sync structure.
// The spaceID parameter is used as a reference name, but the actual space ID
// will be generated by Any-Sync based on the space header.
func (sm *SpaceManager) CreateSpace(referenceName, name string, metadata map[string]string) error {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	// Generate cryptographic keys for the space
	masterKey, _, err := crypto.GenerateRandomEd25519KeyPair()
	if err != nil {
		return fmt.Errorf("failed to generate master key: %w", err)
	}

	metadataKey, _, err := crypto.GenerateRandomEd25519KeyPair()
	if err != nil {
		return fmt.Errorf("failed to generate metadata key: %w", err)
	}

	readKey := crypto.NewAES()

	// Create space payload using Any-Sync's helper
	createPayload := spacepayloads.SpaceCreatePayload{
		SigningKey:     sm.keys.SignKey,
		SpaceType:      "syncspace", // Our space type identifier
		ReplicationKey: 10,          // Arbitrary value for local-only operation
		SpacePayload:   nil,         // No custom payload
		MasterKey:      masterKey,
		ReadKey:        readKey,
		MetadataKey:    metadataKey,
		Metadata:       []byte(name), // Store name in Any-Sync metadata
	}

	storagePayload, err := spacepayloads.StoragePayloadForSpaceCreate(createPayload)
	if err != nil {
		return fmt.Errorf("failed to create storage payload: %w", err)
	}

	// Extract the space ID from the space header (this is the authoritative space ID)
	actualSpaceID := storagePayload.SpaceHeaderWithId.Id

	// Check if this generated space ID already exists
	// (This is very unlikely since each space has unique random keys)
	if _, exists := sm.spaces[actualSpaceID]; exists {
		return fmt.Errorf("space already exists with ID: %s", actualSpaceID)
	}

	// Create space storage using spacestorage package
	storage, err := sm.createSpaceStorage(actualSpaceID, storagePayload)
	if err != nil {
		return fmt.Errorf("failed to create space storage: %w", err)
	}

	// Store space metadata
	now := time.Now().Unix()
	spaceMeta := &SpaceMetadata{
		SpaceID:   actualSpaceID,
		Name:      name,
		Metadata:  metadata,
		CreatedAt: now,
		UpdatedAt: now,
	}

	sm.spaces[actualSpaceID] = spaceMeta
	sm.storages[actualSpaceID] = storage

	if err := sm.saveMetadata(); err != nil {
		// Try to rollback the space storage creation
		ctx := context.Background()
		storage.Close(ctx)
		delete(sm.spaces, actualSpaceID)
		delete(sm.storages, actualSpaceID)
		return fmt.Errorf("failed to save metadata: %w", err)
	}

	return nil
}

// createSpaceStorage creates the actual space storage using anystore.
func (sm *SpaceManager) createSpaceStorage(spaceID string, payload spacestorage.SpaceStorageCreatePayload) (spacestorage.SpaceStorage, error) {
	// Open anystore database for this space
	dbPath := filepath.Join(sm.storageDir, spaceID+".db")

	// Open the database
	ctx := context.Background()
	db, err := anystore.Open(ctx, dbPath, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to open space database: %w", err)
	}

	// Create space storage using Any-Sync's helper
	storage, err := spacestorage.Create(ctx, db, payload)
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to create space storage: %w", err)
	}

	return storage, nil
}

// ListSpaces returns all spaces.
func (sm *SpaceManager) ListSpaces() []*SpaceMetadata {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	spaces := make([]*SpaceMetadata, 0, len(sm.spaces))
	for _, space := range sm.spaces {
		// Create a copy to avoid mutation
		spaceCopy := *space
		spaces = append(spaces, &spaceCopy)
	}

	return spaces
}

// GetSpace retrieves space metadata by ID.
func (sm *SpaceManager) GetSpace(spaceID string) (*SpaceMetadata, error) {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	space, exists := sm.spaces[spaceID]
	if !exists {
		return nil, fmt.Errorf("space not found: %s", spaceID)
	}

	// Return a copy
	spaceCopy := *space
	return &spaceCopy, nil
}

// DeleteSpace removes a space and its storage.
func (sm *SpaceManager) DeleteSpace(spaceID string) error {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	// Check if space exists
	if _, exists := sm.spaces[spaceID]; !exists {
		return fmt.Errorf("space not found: %s", spaceID)
	}

	// Close storage if open
	if storage, ok := sm.storages[spaceID]; ok {
		ctx := context.Background()
		storage.Close(ctx)
		delete(sm.storages, spaceID)
	}

	// Remove storage database file
	dbPath := filepath.Join(sm.storageDir, spaceID+".db")
	if err := os.RemoveAll(dbPath); err != nil {
		return fmt.Errorf("failed to remove space storage: %w", err)
	}

	// Remove from metadata
	delete(sm.spaces, spaceID)

	if err := sm.saveMetadata(); err != nil {
		return fmt.Errorf("failed to save metadata: %w", err)
	}

	return nil
}

// loadMetadata loads space metadata from disk.
func (sm *SpaceManager) loadMetadata() error {
	metadataPath := filepath.Join(sm.dataDir, "spaces_metadata.json")

	data, err := os.ReadFile(metadataPath)
	if err != nil {
		if os.IsNotExist(err) {
			// No metadata file yet, that's fine
			return nil
		}
		return fmt.Errorf("failed to read metadata file: %w", err)
	}

	var spaces []*SpaceMetadata
	if err := json.Unmarshal(data, &spaces); err != nil {
		return fmt.Errorf("failed to unmarshal metadata: %w", err)
	}

	for _, space := range spaces {
		sm.spaces[space.SpaceID] = space
	}

	return nil
}

// saveMetadata persists space metadata to disk.
func (sm *SpaceManager) saveMetadata() error {
	metadataPath := filepath.Join(sm.dataDir, "spaces_metadata.json")

	spaces := make([]*SpaceMetadata, 0, len(sm.spaces))
	for _, space := range sm.spaces {
		spaces = append(spaces, space)
	}

	data, err := json.Marshal(spaces)
	if err != nil {
		return fmt.Errorf("failed to marshal metadata: %w", err)
	}

	if err := os.WriteFile(metadataPath, data, 0600); err != nil {
		return fmt.Errorf("failed to write metadata file: %w", err)
	}

	return nil
}

// Close closes all open space storages.
func (sm *SpaceManager) Close() error {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	ctx := context.Background()
	for _, storage := range sm.storages {
		storage.Close(ctx)
	}
	sm.storages = make(map[string]spacestorage.SpaceStorage)

	return nil
}
