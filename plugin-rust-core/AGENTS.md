# Rust Plugin Development Guide

## Architecture

The plugin uses a unified `AnySyncService` trait with platform-specific implementations:
- **Desktop**: Sidecar process with gRPC communication
- **Mobile**: Direct FFI calls to gomobile bindings

## Adding New Commands

1. **Register command** in `lib.rs`:
   ```rust
   .invoke_handler(tauri::generate_handler![
       commands::your_command,
   ])
   ```

   and extend the `AnySyncService` trait.

2. **Add to service trait** in `lib.rs`:
   ```rust
   async fn your_operation(&self, args: Args) -> Result<Response>;
   ```

3. **Implement for desktop** in `desktop.rs`:
   - Create gRPC client request
   - Handle response and errors

4. **Implement for mobile** in `mobile.rs`:
   - Call FFI function
   - Handle response and errors

5. **Add command handler** in `commands.rs`:
   ```rust
   #[tauri::command]
   async fn your_command(
       service: tauri::State<'_, Box<dyn AnySyncService + Send + Sync>>,
       args: Args,
   ) -> Result<Response, Error> {
       service.your_operation(args).await
   }
   ```

6. **Update permissions**:
   - Add to `permissions/default.toml`
   - Generate `permissions/autogenerated/commands/your_command.toml`
   - Update `permissions/schemas/schema.json`

## Testing

```bash
# Run all tests
cargo test

# Run specific test
cargo test test_name

# With logging
RUST_LOG=debug cargo test
```

## Build Configuration

The `build.rs` script uses environment variables:
- `ANY_SYNC_GO_BINARIES_DIR` - Local binaries directory (development)
- `OUT_DIR` - Cargo build output directory

Platform-specific features determine which binaries are linked or downloaded.

See [root AGENTS.md](../AGENTS.md) for full development workflow.
