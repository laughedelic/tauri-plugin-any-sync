<!-- OPENSPEC:START -->
# OpenSpec Instructions

These instructions are for AI assistants working in this project.

Always open `@/openspec/AGENTS.md` when the request:
- Mentions planning or proposals (words like proposal, spec, change, plan)
- Introduces new capabilities, breaking changes, architecture shifts, or big performance/security work
- Sounds ambiguous and you need the authoritative spec before coding

Use `@/openspec/AGENTS.md` to learn:
- How to create and apply change proposals
- Spec format and conventions
- Project structure and guidelines

Keep this managed block so 'openspec update' can refresh the instructions.

<!-- OPENSPEC:END -->

## Architecture Components

### Go Backend (`go-backend/`)
- **Purpose**: gRPC server providing health check and ping services
- **Technology**: Go with gRPC and Protocol Buffers
- **Entry Point**: `cmd/server/main.go`
- **Build Script**: `build-go-backend.sh` (cross-platform compilation)
- **Testing**: Unit tests in `api/server/health_test.go`

### Rust Plugin (`src/`)
- **Purpose**: Tauri plugin that manages Go sidecar process and provides TypeScript API
- **Key Files**:
  - `desktop.rs` - Sidecar process management and gRPC client
  - `commands.rs` - Tauri command handlers
  - `models.rs` - Data transfer types
  - `proto/` - Generated gRPC client code
- **Dependencies**: tokio, tonic, prost, tempfile, uuid

### TypeScript API (`guest-js/`)
- **Purpose**: Frontend API with Promise-based interface
- **Key Function**: `ping(message?: string): Promise<string | null>`
- **Error Handling**: Structured error propagation from Go backend

### Example App (`examples/tauri-app/`)
- **Purpose**: Demonstration of plugin functionality
- **UI**: Svelte frontend with ping test button
- **Configuration**: Plugin capabilities in `tauri.conf.json`

## Development Workflow

### Adding New API Operations

When adding a new operation (e.g., `storageDelete`), follow these steps across all layers:

#### 1. Protocol Definition (Protobuf)
- **File**: `go-backend/api/proto/{service}.proto`
- **Actions**: Add RPC method, request/response messages

#### 2. Go Backend Implementation
- **Files**: `go-backend/internal/{feature}/*.go`, `go-backend/api/server/{service}.go`
- **Actions**: Implement business logic, add gRPC handler, write unit tests

#### 3. Rust Plugin Integration
- **Files**: `src/models.rs`, `src/desktop.rs`, `src/commands.rs`, `src/lib.rs`
- **Actions**:
  1. Add request/response structs in `models.rs`
  2. Add gRPC client method in `desktop.rs` (10s timeout)
  3. Add command handler in `commands.rs`
  4. Register command in `lib.rs` invoke_handler

#### 4. Tauri Permission System
- **Files**: `permissions/default.toml`, `permissions/schemas/schema.json`, `permissions/autogenerated/commands/{command}.toml`
- **Actions**: Update all 3 files with `allow-{command}` and `deny-{command}` entries

#### 5. TypeScript API
- **File**: `guest-js/index.ts`
- **Actions**: Add typed function with comprehensive JSDoc, then `bun run build`

#### 6. Example App UI
- **File**: `examples/tauri-app/src/App.svelte`
- **Actions**: Add handler, UI elements, and UX considerations

#### 7. Build & Test
```bash
./build-go-backend.sh  # Regenerates protobuf + Go binary
cargo build            # Rebuilds Rust plugin
./run-example.sh       # Test end-to-end
```

#### Common Pitfalls
- **Permission files**: All 3 must be updated and plugin rebuilt
- **Sidecar binary**: Example app uses old binary until Go backend rebuilt
- **Type alignment**: Ensure proto â†” Rust â†” TypeScript types match

## Build System Integration

### Binary Distribution Architecture

The plugin uses an automated binary distribution system with two distinct modes:

**Consumer/CI Mode (Production)**:
- Plugin downloads pre-compiled Go binaries from GitHub Releases
- Binaries are verified using SHA256 checksums
- Consumer's `build.rs` copies binaries to `src-tauri/binaries/`
- Enabled via Cargo features (e.g., `features = ["all"]` or `["macos"]`)

**Local Development Mode**:
- Set `ANY_SYNC_GO_BINARIES_DIR` environment variable to local binaries path
- Plugin copies binaries from local directory instead of downloading
- Allows developers to test Go backend changes immediately
- No network dependency for development workflows

### Build Flow

**Plugin Build** (`build.rs`):
1. Check for `ANY_SYNC_GO_BINARIES_DIR` environment variable
2. **If set** (development mode):
   - Copy binaries from local path to `OUT_DIR/binaries/`
   - Emit warning message
3. **If not set** (consumer/CI mode):
   - Determine enabled features (e.g., `macos`, `windows`)
   - Download binaries from GitHub Releases for plugin version
   - Download and parse `checksums.txt` from release assets
   - Verify SHA256 checksums for each binary (desktop + mobile)
   - Store verified binaries in `OUT_DIR/binaries/`
   - Fail build with clear error if download or verification fails
4. **For Android**: Symlink (Unix) or copy (Windows) `any-sync-android.aar` from binaries to `android/libs/`
5. Emit `cargo:binaries_dir=<path>` for consumer propagation (both modes)

**Note**: In development mode, symlinks are used instead of copying to save disk space and improve build times. On Windows, files are copied as a fallback since symlinks require admin privileges.

**Android .aar Placement**: The plugin's build.rs automatically manages the .aar placement by creating a symlink/copy to `android/libs/any-sync-android.aar`. This allows the plugin's `android/build.gradle.kts` to reference `implementation(files("libs/any-sync-android.aar"))` relative to its own directory, which works in both development (local path) and production (published crate) scenarios.

**Consumer Build** (`build.rs` in consuming app):
1. Read `DEP_TAURI_PLUGIN_ANY_SYNC_BINARIES_DIR` environment variable from plugin
2. Create symlink to binaries directory (or copy on Windows) at `src-tauri/binaries/`
3. Configure `externalBin` in `tauri.conf.json` to bundle binaries
4. Add `.taurignore` to prevent rebuild loops from file watcher

### Cargo Configuration

**Features** (select which platforms to download):
- Individual targets: `x86_64-apple-darwin`, `aarch64-apple-darwin`, `x86_64-unknown-linux-gnu`, `aarch64-unknown-linux-gnu`, `x86_64-pc-windows-msvc`
- Platform groups: `macos`, `linux`, `windows`
- All: `all`

**Links** (`links = "tauri-plugin-any-sync"`):
- Enables metadata propagation via environment variables
- Allows consumer `build.rs` to receive `DEP_TAURI_PLUGIN_ANY_SYNC_BINARIES_DIR`

### Development Workflow

1. **Edit Go backend code**:
   ```bash
   # Edit files in go-backend/
   vim go-backend/cmd/server/main.go
   ```

2. **Build binaries locally**:
   ```bash
   ./build-go-backend.sh
   # or for all platforms:
   ./build-go-backend.sh --cross
   ```

3. **Set environment variable**:
   ```bash
   # One-off
   export ANY_SYNC_GO_BINARIES_DIR=./binaries
   
   # Or persistent in .cargo/config.toml:
   [env]
   ANY_SYNC_GO_BINARIES_DIR = { value = "/path/to/binaries", force = true }
   ```

4. **Build plugin**:
   ```bash
   cargo build
   # Plugin will use local binaries instead of downloading
   ```

### Release Workflow

1. **Bump version** in `Cargo.toml`
2. **Create Git tag**: `git tag v0.2.0`
3. **Push tag**: `git push origin v0.2.0`
4. **GitHub Actions triggers** `.github/workflows/release.yml`:
   - Builds Go binaries for all platforms (`./build-go-backend.sh --cross`)
   - Generates SHA256 checksums
   - Creates GitHub Release
   - Uploads binaries + `checksums.txt`
5. **Consumers update** dependency version
6. **Plugin downloads** matching binaries on next `cargo build`

### Automated Build Process

1. **Rust Build**: `cargo build` triggers `build.rs`
2. **Plugin build.rs**: Downloads or uses local binaries (depending on env var)
3. **Protobuf**: Both Go and Rust code generated from same `.proto` file
4. **Binaries**: Output to `OUT_DIR/binaries/` (not committed)
5. **Consumer build.rs**: Copies to `src-tauri/binaries/` via metadata propagation

### Cross-Platform Support

**Available Platforms**:
- **macOS**: `any-sync-x86_64-apple-darwin` (Intel), `any-sync-aarch64-apple-darwin` (Apple Silicon)
- **Linux**: `any-sync-x86_64-unknown-linux-gnu` (x64), `any-sync-aarch64-unknown-linux-gnu` (ARM64)
- **Windows**: `any-sync-x86_64-pc-windows-msvc` (x64)
- **Android**: `any-sync-android.aar` (arm64-v8a, armeabi-v7a, x86, x86_64)

## Communication Flow

### Desktop (gRPC Sidecar)
```
TypeScript â†’ Rust Commands â†’ Desktop Service â†’ gRPC Client â†’ Go Sidecar â†’ AnyStore
```
- Go backend runs as separate process (bundled binary)
- IPC via gRPC over localhost

### Mobile (gomobile binaries Embedded)
```
TypeScript â†’ Rust Commands â†’ Mobile Service â†’ Kotlin/Swift Plugin â†’ JNI/FFI â†’ Go Library â†’ AnyStore
```
- Go backend compiled as native library (.aar/.xcframework)
- Direct in-process function calls via gomobile

**Shared:** Same TypeScript API, same Go storage layer (>95% code reuse)

## Tooling Requirements

### Required Tools
- **Go**: 1.21+ (for backend)
- **Rust**: 1.77+ (for plugin)
- **protoc**: Protocol Buffer compiler
- **Node.js**: For TypeScript compilation and example app
- **Tauri CLI**: For app development

### Development Dependencies
```bash
# Go tools
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest

# Rust tools (installed via cargo)
cargo install cargo-watch
cargo install cargo-audit
```

## Testing Strategy

### Unit Tests
- **Go**: `go test ./...` - Tests gRPC services
- **Rust**: `cargo test` - Tests plugin logic
- **Coverage**: Aim for >80% code coverage

### Integration Tests
- **Process Management**: Sidecar startup/shutdown
- **gRPC Communication**: End-to-end message passing
- **Error Handling**: Proper error propagation
- **Resource Cleanup**: Memory and process cleanup

### Manual Testing Checklist
- [ ] Go backend starts and listens on random port
- [ ] Rust plugin spawns sidecar process
- [ ] gRPC connection established successfully
- [ ] Ping request flows through all layers
- [ ] Response returns to UI correctly
- [ ] Sidecar process shuts down gracefully
- [ ] Error handling works across boundaries

## Performance Considerations

### Phase 0 Optimizations
- **Startup Time**: <2 seconds for sidecar spawn
- **Request Latency**: <50ms for simple ping
- **Memory Usage**: <10MB for idle sidecar
- **Binary Size**: <15MB per platform binary

### Monitoring
- **Health Checks**: Every 30 seconds
- **Connection Pooling**: Handled by gRPC library
- **Resource Limits**: Configurable via environment variables

## Security Architecture

### Phase 0 Security
- **Process Isolation**: Sidecar process separates concerns
- **Localhost Only**: Server binds to localhost by default
- **Input Validation**: All gRPC inputs validated
- **No Authentication**: Basic functionality only (Phase 1+)

### Future Security (Phase 1+)
- **Mutual TLS**: Encrypted gRPC communication
- **Authentication**: User authentication for backend
- **Authorization**: Permission-based access control
- **Audit Logging**: Security event logging

## Troubleshooting

### Common Issues
1. **Port Conflicts**: Use random port allocation (port 0)
2. **Build Failures**: Check Go toolchain and protoc installation
3. **gRPC Timeouts**: Increase timeout values in configuration
4. **Process Leaks**: Verify graceful shutdown implementation
5. **Cross-Compilation**: Ensure target-specific toolchains

### Debug Commands
```bash
# Enable verbose logging
export ANY_SYNC_LOG_LEVEL=debug

# Check Go backend logs
./binaries/any-sync-aarch64-apple-darwin --port 8080

# Check Rust plugin logs
RUST_LOG=debug cargo run

# Test gRPC directly
grpcurl -plaintext localhost:8080 anysync.HealthService/Ping
```

## Phase 0 Success Criteria

âœ… **Completed**:
- Go backend compiles and runs as standalone server
- Desktop sidecar process spawns and communicates via gRPC
- TypeScript `ping` command round-trips through all layers
- Example app successfully calls plugin and displays response
- Build process produces all necessary artifacts
- Basic error handling works across all boundaries

ðŸ”„ **Ready for Phase 1**:
- AnySync/AnyStore integration
- Mobile gomobile binding structure
- Advanced gRPC streaming
- Production-ready error handling
- Comprehensive testing
